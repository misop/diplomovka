#version 430

layout(vertices = 3) out;

in _{
	vec4 vertex_eye;
	vec4 normal_eye;
	vec4 light_eye;
} v[];

const float tessLevel = 5;
//screenHeight/pixelsPerEdge
const float EdgesPerScreenHeight = 1080.0/150.0;
layout(location = 1) uniform mat4 ViewMatrix;
layout(location = 2) uniform mat4 ProjectionMatrix;

out _{
	vec4 vertex_eye;
	vec4 normal_eye;
	vec4 light_eye;
} tc[];

//Obtain the diameter of a bounding sphere on each edge transformed into clip space and multiple by the shader constant to obtain a tessellation factor for the edge.
//Dividing by ClipPos.W will perspective correct the diameter
float GetPostProjectionSphereExtent(in vec4 Origin, in float Diameter)
{
    vec4 ClipPos = ProjectionMatrix * ViewMatrix * Origin;
    return abs(Diameter * ProjectionMatrix[1][1] / ClipPos.w);
}

float CalculateTessellationFactor(in vec4 Control0, in vec4 Control1)
{
    float e0 = distance(Control0, Control1);
    vec4 m0 = (Control0 + Control1)/2;
    return max(1, EdgesPerScreenHeight * GetPostProjectionSphereExtent(m0, e0));
}

void main(void) {
	//set tessellation levels just once
	if (gl_InvocationID == 0) {
		//outter levels
		gl_TessLevelOuter[0] = CalculateTessellationFactor(gl_in[0].gl_Position, gl_in[1].gl_Position);
		gl_TessLevelOuter[1] = CalculateTessellationFactor(gl_in[1].gl_Position, gl_in[2].gl_Position);
		gl_TessLevelOuter[2] = CalculateTessellationFactor(gl_in[2].gl_Position, gl_in[0].gl_Position);
		//inner level
		gl_TessLevelInner[0] = max(max(gl_TessLevelOuter[0], gl_TessLevelOuter[1]), gl_TessLevelOuter[2]);
	}
	//pass parameters
	tc[gl_InvocationID].vertex_eye = v[gl_InvocationID].vertex_eye;
	tc[gl_InvocationID].normal_eye = v[gl_InvocationID].normal_eye;
	tc[gl_InvocationID].light_eye = v[gl_InvocationID].light_eye;

	gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
}