#version 430

layout(vertices = 3) out;

in _{
	vec4 vertex_eye;
	vec4 normal_eye;
	vec4 light_eye;
	vec2 uv;
} v[];

const float tessLevel = 5;
//screenHeight/pixelsPerEdge
layout(location = 1) uniform mat4 ViewMatrix;
layout(location = 2) uniform mat4 ProjectionMatrix;
layout(location = 4) uniform vec4 Material;
layout(location = 5) uniform float PixelsPerEdge;
layout(location = 8) uniform float ScreenHeight;

out _{
	vec4 vertex_eye;
	vec4 normal_eye;
	vec4 light_eye;
	vec2 uv;
} tc[];

//Obtain the diameter of a bounding sphere on each edge transformed into clip space and multiple by the shader constant to obtain a tessellation factor for the edge.
//Dividing by ClipPos.W will perspective correct the diameter
float GetPostProjectionSphereExtent(in vec4 Origin, in float Diameter)
{
    //vec4 ClipPos = ProjectionMatrix * ViewMatrix * Origin;
    vec4 ClipPos = ProjectionMatrix * Origin;
    return abs(Diameter * ProjectionMatrix[1][1] / ClipPos.w);
}

float CalculateTessellationFactor(in vec4 Control0, in vec4 Control1, in vec4 Normal1, in vec4 Normal2)
{
	//no tessellation for you
	if (Material.x < 0.5) return 1.0;
	vec4 n = normalize((Normal1 + Normal2)/2.0);
	//tessellate only facing
	vec4 eye_dir = vec4(0,0,-1,0);
	if (dot(eye_dir, n) > 0) {
		return 1;
	}
	//tessellate only in fron of camera
    vec4 m0 = (Control0 + Control1)/2;
	if (dot(eye_dir, m0) > 0) {
		return 1;
	}
	
    float e0 = distance(Control0, Control1);
    return max(1, ScreenHeight / PixelsPerEdge * GetPostProjectionSphereExtent(m0, e0));
    //return max(1, EdgesPerScreenHeight * GetPostProjectionSphereExtent(m0, e0));
}

void main(void) {
	//set tessellation levels just once
	if (gl_InvocationID == 0) {
		//outter levels
		//gl_TessLevelOuter[0] = CalculateTessellationFactor(gl_in[0].gl_Position, gl_in[1].gl_Position, v[0].normal_eye, v[1].normal_eye);
		//gl_TessLevelOuter[1] = CalculateTessellationFactor(gl_in[1].gl_Position, gl_in[2].gl_Position, v[1].normal_eye, v[2].normal_eye);
		//gl_TessLevelOuter[2] = CalculateTessellationFactor(gl_in[2].gl_Position, gl_in[0].gl_Position, v[2].normal_eye, v[0].normal_eye);
		gl_TessLevelOuter[0] = CalculateTessellationFactor(v[0].vertex_eye, v[1].vertex_eye, v[0].normal_eye, v[1].normal_eye);
		gl_TessLevelOuter[1] = CalculateTessellationFactor(v[1].vertex_eye, v[2].vertex_eye, v[1].normal_eye, v[2].normal_eye);
		gl_TessLevelOuter[2] = CalculateTessellationFactor(v[2].vertex_eye, v[0].vertex_eye, v[2].normal_eye, v[0].normal_eye);
		//inner level
		gl_TessLevelInner[0] = max(max(gl_TessLevelOuter[0], gl_TessLevelOuter[1]), gl_TessLevelOuter[2]);
	}
	//pass parameters
	tc[gl_InvocationID].vertex_eye = v[gl_InvocationID].vertex_eye;
	tc[gl_InvocationID].normal_eye = v[gl_InvocationID].normal_eye;
	tc[gl_InvocationID].light_eye = v[gl_InvocationID].light_eye;
	tc[gl_InvocationID].uv = v[gl_InvocationID].uv;

	gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
}